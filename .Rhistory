c(i, theta)
}
plot(com.size.drift[,2] ~ com.size.drift[,1],
xlab ="Community size",
ylab= "Theta")
abline(lm(com.size.drift[,2] ~ com.size.drift[,1]))
plot(com.size.drift[,2] ~ com.size.drift[,1],
xlab ="Pop. size of 10 species",
ylab= "Theta")
abline(lm(com.size.drift[,2] ~ com.size.drift[,1]))
rep(seq(1, 10, 1), i)
i <- 1
rep(seq(1, 10, 1), i)
i <- 1
i <- 2
rep(seq(1, 10, 1), i)
j <- 10
i <- 1
j <- 10
rep(seq(1, j, 1), i)
com.size.drift <- foreach(j = seq(10, 100, 10))%do%{
foreach(i = 1:10, .combine = "rbind")%do%{
start <- rep(seq(1, j, 1), i)
a <- untb(start=start, prob=0.05, D = 1, gens=1000, keep=TRUE, meta = 1:1000)
theta <- optimal.theta(a)
c(i, theta)
}
}
plot(com.size.drift[,2] ~ com.size.drift[,1],
xlab ="Community-Population size",
ylab= "Theta (Ecological Drift)")
abline(lm(com.size.drift[,2] ~ com.size.drift[,1]))
com.size.drift
com.size.drift <- do.call(rbind, com.size.drift)
plot(com.size.drift[,2] ~ com.size.drift[,1],
xlab ="Community-Population size",
ylab= "Theta (Ecological Drift)")
abline(lm(com.size.drift[,2] ~ com.size.drift[,1]))
head(com.size.drift)
com.size.drift <- data.frame(com.size.drift)
head(com.size.drift)
library(ggplot2)
ggplot(com.size.drift, aes(x = X1, y = X2))+
geom_point()
ggplot(com.size.drift, aes(x = X1, y = X2))+
geom_point() + geom_smooth(method = "loess")
ggplot(com.size.drift, aes(x = X1, y = X2))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)")
ggplot(com.size.drift, aes(x = X1, y = X2))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)") +
theme_bw()
com.size.drift
max.com.size <- 1000
max.pop.size <- 100
max.com.size <- 100
max.pop.size <- 10
com.size.drift <- foreach(j = seq(max.com.size/10, max.com.size, 10),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
start <- rep(seq(1, j, 1), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=1000,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(size = paste(j, i), theta = theta)
}
}
max.com.size <- 100
max.pop.size <- 10
com.size.drift <- foreach(j = seq(max.com.size/10, max.com.size, 10),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
start <- rep(seq(1, j, 1), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(size = paste(j, i), theta = theta)
}
}
com.size.drift
com.size.drift <- data.frame(com.size.drift)
factor(com.size.drift$size)
as.numeric(factor(com.size.drift$size))
com.size.drift <- foreach(j = seq(max.com.size/10, max.com.size, 10),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
start <- rep(seq(1, j, 1), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
com.size.drift <- data.frame(com.size.drift)
head(com.size.drift)
com.size.drift$com.size * com.size.drift$pop.size
com.size.drift$size  = com.size.drift$com.size * com.size.drift$pop.size
ggplot(com.size.drift, aes(x = size, y = theta))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)") +
theme_bw()
ggplot(com.size.drift, aes(x = pop.size, y = theta))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)") +
theme_bw()
ggplot(com.size.drift, aes(x = com.size, y = theta))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)") +
theme_bw()
ggplot(com.size.drift, aes(x = pop.size, y = theta))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)") +
theme_bw()
library(plotly)
library(plotly)
plot_ly(com.size.drift, x = ~pop.size, y = ~com.size, z = ~theta, color = ~am, colors = c('#BF382A', '#0C4B8E')) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Weight'),
yaxis = list(title = 'Gross horsepower'),
zaxis = list(title = '1/4 mile time')))
plot_ly(com.size.drift, x = ~pop.size, y = ~com.size, z = ~theta, colors = c('#BF382A', '#0C4B8E')) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Weight'),
yaxis = list(title = 'Gross horsepower'),
zaxis = list(title = '1/4 mile time')))
plot_ly(com.size.drift, x = ~pop.size, y = ~com.size, z = ~theta, colors = c('#BF382A', '#0C4B8E')) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Population size'),
yaxis = list(title = 'Community size'),
zaxis = list(title = 'Theta (Drift)')))
max.com.size <- 1000
max.pop.size <- 100
com.size.drift <- foreach(j = seq(max.com.size/10, max.com.size, 10),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
start <- rep(seq(1, j, 1), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
com.step <- 10
pop.step <- 10
cat(j, i)
max.com.size <- 1000
com.step <- 10
max.pop.size <- 100
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
cat(j, i)
start <- rep(seq(1, j, 1), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
1:max.pop.size
seq(max.com.size/com.step, max.com.size, com.step)
max.com.size <- 1000
com.step <- 100
seq(max.com.size/com.step, max.com.size, com.step)
max.com.size <- 1010
com.step <- 100
seq(max.com.size/com.step, max.com.size, com.step)
max.com.size <- 1100
com.step <- 100
max.com.size <- 1100
seq(max.com.size/com.step, max.com.size, com.step)
max.com.size <- 1000
com.step <- 100
max.com.size <- 1000
com.step <- 100
max.pop.size <- 100
pop.step <- 10
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
cat(j, i)
start <- rep(seq(1, j, 10), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
seq(1, j, 10)
max.com.size <- 1000
com.step <- 100
max.pop.size <- 100
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
cat(j, i)
start <- rep(seq(1, j, i), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
1:max.pop.size
seq(1, j, i)
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
print(j, i)
start <- rep(seq(1, j, i), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
print(j)
print(i)
start <- rep(seq(1, j, i), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
print(j)
print(i)
start <- rep(seq(1, j, i), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
max.com.size <- 1000
com.step <- 100
max.pop.size <- 100
com.size.drift <- foreach(j = seq(max.com.size/com.step, max.com.size, com.step),
.combine = "rbind")%do%{
foreach(i = 1:max.pop.size, .combine = "rbind")%do%{
# print(j)
# print(i)
start <- rep(seq(1, j, i), i)
a <- untb(start=start, prob=0.05, D = 1,
gens=150,
keep=TRUE,
meta = 1:max.com.size)
theta <- optimal.theta(a)
c(com.size = j, pop.size= i, theta = theta)
}
}
com.size.drift <- data.frame(com.size.drift)
com.size.drift$size  = com.size.drift$com.size * com.size.drift$pop.size
ggplot(com.size.drift, aes(x = pop.size, y = theta))+
geom_point() + geom_smooth(method = "loess") +
xlab("Community-Population size") +
ylab("Theta (Ecological Drift)") +
theme_bw()
library(plotly)
plot_ly(com.size.drift, x = ~pop.size, y = ~com.size, z = ~theta, colors = c('#BF382A', '#0C4B8E')) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Population size'),
yaxis = list(title = 'Community size'),
zaxis = list(title = 'Theta (Drift)')))
plot_ly(com.size.drift, x = ~pop.size, y = ~com.size, z = ~theta) %>%
add_markers() %>%
layout(scene = list(xaxis = list(title = 'Population size'),
yaxis = list(title = 'Community size'),
zaxis = list(title = 'Theta (Drift)')))
library(ips)
dna <- read.fas("Documents/R/pkgs/polenta/dev/data/cortinarius_28s_ms.fas")
mafft(dna, options = "--thread 4 --adjustdirection --nwildcard")
## This code is part of the ips package
## Â© C. Heibl 2014 (last update 2017-04-06)
#' @title Sequence Alignment with MAFFT
#' @description This function is a wrapper for MAFFT and can be used for
#'   (profile) aligning of DNA and aminoacis sequences.
#' @param x An object of class \code{DNAbin} or \code{AAbin}.
#' @param y An object of class \code{DNAbin} or \code{AAbin}, if given both
#'   \code{x} and \code{y} are preserved and aligned to each other ("profile
#'   alignment").
#' @param add A character string giving the method used for adding \code{y} to
#'   \code{x}: \code{"add"}, \code{"addprofile"} (default), or any unambiguous
#'   abbreviation of these.
#' @param method A character string giving the alignment method. Available
#'   accuracy-oriented methods for less than 200 sequences are
#'   \code{"localpair"}, \code{"globalpair"}, and \code{"genafpair"};
#'   \code{"retree 1"} and \code{"retree 2"} are for speed-oriented alignment.
#'   The default is \code{"auto"}, which lets MAFFT choose an appropriate
#'   alignment method.
#' @param maxiterate An integer giving the number of cycles ofa iterative
#'   refinement to perform. Possible choices are \code{0}: progressive method,
#'   no iterative refinement (default); \code{2}: two cycles of iterative
#'   refinement; \code{1000}: at most 1000 cycles of iterative refinement.
#' @param op A numeric giving the \code{gap opening penalty} at group-to-group
#'   alignment; default 1.53.
#' @param ep A numeric giving the offset value, which works like \code{gap
#'   extension penalty}, for group-to-group alignment; default 0.0, but 0.123 is
#'   recommended if no long indels are expected.
#' @param gt An object of class \code{\link{phylo}} that is to be used as a
#'   guide tree during alignment.
#' @param options A vector of mode character specifying addional arguments to
#'   MAFFT, that are not included in \code{mafft} such as, e.g.,
#'   \code{--adjustdirection}.
#' @param thread Integer giving the number of physical cores MAFFT should use;
#'   with \code{thread = -1} the number of cores is determined automatically.
#' @param exec A character string giving the path to the MAFFT executable
#'   including its name, e.g. something like \code{/user/local/bin/mafft} under
#'   UNIX-alikes.
#' @param quiet Logical, if set to \code{TRUE}, mafft progress is printed out on
#'   the screen.
#' @param file A character string indicating the filename of the output FASTA
#'   file; if this is missing the the alignment will be returned as  matrix of
#'   class \code{DNAbin} or \code{AAbin}.
#' @details \code{"localpair"} selects the \bold{L-INS-i} algorithm, probably
#'   most accurate; recommended for <200 sequences; iterative refinement method
#'   incorporating local pairwise alignment information.
#'
#'   \code{"globalpair"} selects the \bold{G-INS-i} algorithm suitable for
#'   sequences of similar lengths; recommended for <200 sequences; iterative
#'   refinement method incorporating global pairwise alignment information.
#'
#'   \code{"genafpair"} selects the \bold{E-INS-i} algorithm suitable for
#'   sequences containing large unalignable regions; recommended for <200
#'   sequences.
#'
#'   \code{"retree 1"} selects the \bold{FFT-NS-1} algorithm, the simplest
#'   progressive option in MAFFT; recommended for >200 sequences.
#'
#'   \code{"retree 2"} selects the \bold{FFT-NS-2} algorithm that uses a second
#'   iteration of alignment based on a guide tree computed from an FFT-NS-1
#'   aligment; this is the default in MAFFT; recommended for >200 sequences.
#' @return A \code{matrix} of class \code{"DNAbin"} or \code{"AAbin"}.
#' @references Katoh, K. and H. Toh. 2008. Recent developments in the MAFFT
#'   multiple sequence alignment program. \emph{Briefings in Bioinformatics}
#'   \bold{9}: 286-298.
#'
#'   Katoh, K., K.-i. Kuma, H. Toh, and T. Miyata. 2005. Mafft version 5:
#'   improvement in accuracy of multiple sequence alignment. \emph{Nucleic Acids
#'   Research} \bold{33}: 511--518.
#'
#'   Katoh, K., K. Misawa, K.-i. Kuma, and T. Miyata. 2002. Mafft: a novel
#'   method for rapid multiple sequence alignment based on fast Fourier
#'   transform. \emph{Nucleid Acids Research} \bold{30}: 3059--3066.
#'
#'   \url{http://mafft.cbrc.jp/alignment/software/index.html}
#' @note \code{mafft} was last updated and tested to work with MAFFT 7.205. If
#'   you have problems getting the function to work with a newer version of
#'   MAFFT, please contact the package maintainer.
#' @seealso \code{\link{read.fas}} to import DNA sequences; \code{\link{prank}}
#'   for another alignment algorithm; \code{\link{gblocks}} and
#'   \code{\link{aliscore}} for alignment cleaning.
#' @importFrom phangorn write.phyDat
#' @export
mafft <- function(x, y, add, method = "auto", maxiterate = 0,
op = 1.53, ep = 0.0, gt, options,
thread = -1, exec, quiet, file){
## CHECKS and DEFINITIONS
## ----------------------
if (!inherits(x, c("DNAbin", "AAbin")))
stop("'x' is not of class 'DNAbin' or 'AAbin'")
os <- .Platform$OS
if (missing(quiet)) quiet <- TRUE
qut <- ifelse(quiet, " --quiet ", " ")
if (missing(exec)) exec <- "/usr/local/bin/mafft"
maxiterate <- match.arg(as.character(maxiterate), c("0", "2", "1000"))
## temporary input/output files
## ----------------------------
fns <- vector(length = 4)
for (i in seq_along(fns))
fns[i] <- tempfile(pattern = "mafft", tmpdir = tempdir(), fileext = ".fas")
unlink(fns[file.exists(fns)])
method <- match.arg(method, c("auto", "localpair", "globalpair",
"genafpair", "parttree",
"retree 1", "retree 2"))
## guide tree
## ----------
if (missing(gt)){
gt <- ""
} else {
if (!inherits(gt, "phylo"))
stop("object \"gt\" is not of class \"phylo\"")
if (!all(names(x) %in% gt$tip.label))
stop("guide tree does not match sequence names")
gt$tip.label <- match(names(x), gt$tip.label)
if (!is.binary.tree(gt))
gt <- multi2di(gt)
if (is.null(gt$edge.length))
gt$edge.length <- rep(1, nrow(gt$edge))
phylo2mafft(gt, file = fns[4])
gt <- paste(" --treein", fns[4], "")
}
## multithreading
## --------------
thread <- paste("--thread", thread)
thread <- paste(rep(" ", 2), collapse = thread)
## additional arguments specified by the user
## ------------------------------------------
if (missing(options)){
options <- " "
} else {
# options <- match.arg(options, c("--adjustdirection",
#                                 "--adjustdirectionaccurately"))
options <- paste(options, collapse = " ")
options <- paste(rep(" ", 2), collapse = options)
}
## write input files and prepare call to MAFFT
## -------------------------------------------
if (missing(y)){
if (inherits(x, "DNAbin")){ write.fas(x, fns[1])  }
if (inherits(x, "AAbin")) { write.fas(x, fns[1]) }
call.mafft <- paste(exec, " --", method, " --",
"maxiterate ", maxiterate, qut, "--op ", op,
" --ep ", ep, gt, options, thread,
fns[1], " > ", fns[3], sep = "")
} else {
if (!inherits(y, c("DNAbin", "AAbin"))) stop("'y' is not of class 'DNAbin' or 'AAbin'")
if (missing(add)) add <- "addprofile"
add <- match.arg(add, c("add", "addprofile"))
add <- paste("--", add, sep = "")
write.fas(x, fns[1])
write.fas(y, fns[2])
call.mafft <- paste(exec, qut, add, fns[2], fns[1], ">", fns[3])
}
if (!quiet) message(call.mafft)
## execute MAFFT on UNIX
## ---------------------
if (os == "unix"){
system(call.mafft, intern = FALSE, ignore.stdout = FALSE)
res <- (file.info(fns[3])$size > 1) #allow line break in empty file
if (res != 0) {
res <- read.dna(fns[3],format="fasta")
}
## execute MAFFT on WINDOWS
## ------------------------
} else {
res <- system(call.mafft, intern = TRUE, ignore.stderr = FALSE)
if (length(grep("error|ERROR", res))){
res <- 0
}
else {
res <- read.dna(fns[3],format="fasta")
}
}
unlink(fns[file.exists(fns)])
if (!missing(file)){
write.fas(res, file)
} else {
return(res)
}
}
mafft(dna, options = "--thread 4 --adjustdirection --nwildcard")
setwd("Documents/R/pkgs/rusda/")
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
install.packages("roxygen2")
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::use_vignette("my-vignette")
getwd()
knit_with_parameters('~/Documents/R/pkgs/rusda/vignettes/vignette.Rmd')
